<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Will's Inference Calculations</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.5;
            padding: 1rem;
        }

        .container { max-width: 1200px; margin: 0 auto; }

        h1 { font-size: 1.5rem; margin-bottom: 1rem; }
        h2 { font-size: 1rem; margin-bottom: 0.5rem; font-weight: 600; }

        .card {
            background: white;
            border: 1px solid #ddd;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .chart-container { height: 400px; }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }

        th, td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th { font-weight: 600; background: #f9f9f9; }

        .badge {
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .badge-mla { background: #e9d5ff; color: #7c3aed; }
        .badge-mha { background: #d1fae5; color: #059669; }
        .badge-swa { background: #fef3c7; color: #d97706; }
        .badge-err { background: #fee2e2; color: #dc2626; }

        input, select {
            padding: 0.4rem;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.85rem;
            width: 100%;
        }

        button {
            padding: 0.4rem 0.8rem;
            background: #4f46e5;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        button:hover { background: #4338ca; }
        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .controls select { width: auto; }

        .legend-note {
            font-size: 0.75rem;
            color: #666;
            margin-top: 0.5rem;
        }

        .table-wrap { max-height: 350px; overflow-y: auto; }

        .slider-controls {
            display: flex;
            gap: 2rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .slider-group {
            flex: 1;
            min-width: 200px;
        }

        .slider-group label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .slider-group label span {
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .preset-btn {
            padding: 0.15rem 0.4rem;
            font-size: 0.7rem;
            background: #e5e7eb;
            color: #374151;
            border: 1px solid #d1d5db;
        }

        .preset-btn:hover {
            background: #d1d5db;
        }

        .download-btn {
            padding: 0.15rem 0.4rem;
            font-size: 0.65rem;
            background: #f3f4f6;
            color: #6b7280;
            border: 1px solid #d1d5db;
            margin-left: 0.5rem;
            vertical-align: middle;
        }

        .download-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .scatter-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .scatter-col {
            flex: 1;
            min-width: 300px;
        }

        .scatter-col h3 {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .chart-container-half {
            height: 350px;
        }

        @media (max-width: 700px) {
            .scatter-col {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Will's Inference Calculations</h1>
        <p style="font-style: italic; color: #666; margin-bottom: 0.25rem;">Things everyone should know about inference</p>
        <p style="font-size: 0.85rem; color: #666; margin-bottom: 1rem;">
            Will Arnold &mdash;
            <a href="https://linkedin.com/in/~arnold">LinkedIn</a> &middot;
            <a href="https://github.com/Aphoh">GitHub</a> &middot;
            will@swaglu.com &middot; warnold@nvidia.com
        </p>

        <div class="card"><h2>Roofline Calculations</h2><ul style="list-style: none; padding: 0;"><li><a href="posts/dp-vs-tp-attention.html">DP Attention vs TP in GQA</a></li><li><a href="posts/dp-vs-tp-mla.html">DP Attention vs TP in MLA</a></li></ul></div>

        <div class="card">
            <div class="controls">
                <label>Data Type:</label>
                <select id="dtype">
                    <option value="bf16">BF16</option>
                    <option value="fp8" selected>FP8</option>
                </select>
            </div>
        </div>

        <div class="card">
            <h2>KV Cache Bytes per Token <button class="download-btn" onclick="downloadChart('barChart', 'kv-bytes-per-token', 'KV Cache Bytes per Token')">↓ PNG</button></h2>
            <div class="chart-container">
                <canvas id="barChart"></canvas>
            </div>
            <div class="legend-note">
                <span class="badge badge-mla">MLA</span> Multi-head Latent Attention |
                <span class="badge badge-mha">MHA</span> Multi-Head Attention |
                <span class="badge badge-swa">SWA</span> Sliding Window
            </div>
        </div>

        <div class="card">
            <h2>Model Size vs KV Cache Bytes per Token</h2>
            <div class="scatter-row">
                <div class="scatter-col">
                    <h3>Active Parameters <button class="download-btn" onclick="downloadChart('scatterChartActive', 'active-params-vs-kv', 'Active Parameters vs KV Cache Bytes per Token')">↓ PNG</button></h3>
                    <div class="chart-container-half">
                        <canvas id="scatterChartActive"></canvas>
                    </div>
                </div>
                <div class="scatter-col">
                    <h3>Total Parameters <button class="download-btn" onclick="downloadChart('scatterChartTotal', 'total-params-vs-kv', 'Total Parameters vs KV Cache Bytes per Token')">↓ PNG</button></h3>
                    <div class="chart-container-half">
                        <canvas id="scatterChartTotal"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>KV Cache Size vs Sequence Length <button class="download-btn" onclick="downloadChart('lineChart', 'kv-vs-seqlen', 'KV Cache Size vs Sequence Length')">↓ PNG</button></h2>
            <div class="chart-container">
                <canvas id="lineChart"></canvas>
            </div>
        </div>

        <div class="card">
            <h2>Max Tokens in Flight (per GPU) <button class="download-btn" onclick="downloadChart('batchChart', 'max-tokens-in-flight', 'Max Tokens in Flight (per GPU)')">↓ PNG</button></h2>
            <p style="font-size: 0.8rem; color: #666; margin-bottom: 0.75rem;">
                Total tokens = (GPU × 0.9 − weights/N) / KV per token = batch × seq_len
            </p>
            <div class="slider-controls">
                <div class="slider-group">
                    <label>GPU Memory: <span id="batch-gpu-memory-value">192 GB</span>
                        <span style="margin-left: 0.5rem;">
                            <button type="button" class="preset-btn" onclick="setGpuMemory(80)">80</button>
                            <button type="button" class="preset-btn" onclick="setGpuMemory(192)">192</button>
                            <button type="button" class="preset-btn" onclick="setGpuMemory(280)">280</button>
                        </span>
                    </label>
                    <input type="range" id="batch-gpu-memory" min="1" max="280" value="192">
                </div>
                <div class="slider-group" style="flex: 0.5; min-width: 100px;">
                    <label>GPUs</label>
                    <select id="num-gpus">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="4">4</option>
                        <option value="8" selected>8</option>
                        <option value="16">16</option>
                        <option value="32">32</option>
                        <option value="64">64</option>
                    </select>
                </div>
                <div class="slider-group" style="flex: 0.5; min-width: 120px;">
                    <label>Weight Precision</label>
                    <select id="weight-dtype">
                        <option value="fp16">FP16 (2B/param)</option>
                        <option value="fp8" selected>FP8 (1B/param)</option>
                        <option value="nvfp4">NVFP4 (~0.56B/param)</option>
                    </select>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="batchChart"></canvas>
            </div>
            <div class="legend-note">
                <span class="badge badge-mla">MLA</span> Multi-head Latent Attention |
                <span class="badge badge-mha">MHA</span> Multi-Head Attention |
                <span class="badge badge-swa">SWA</span> Sliding Window |
                <span class="badge badge-err">—</span> Exceeds GPU capacity
            </div>
        </div>

        <div class="card">
            <h2>Model Details</h2>
            <div class="table-wrap">
                <table>
                    <thead>
                        <tr>
                            <th>Model</th>
                            <th>Type</th>
                            <th>Layers</th>
                            <th>KV Heads</th>
                            <th>Head Dim</th>
                            <th>BF16 B/tok</th>
                            <th>FP8 B/tok</th>
                            <th>128K BF16</th>
                            <th>128K FP8</th>
                        </tr>
                    </thead>
                    <tbody id="model-tbody"></tbody>
                </table>
            </div>
            <div class="legend-note">
                <span class="badge badge-mla">MLA</span> Multi-head Latent Attention |
                <span class="badge badge-mha">MHA</span> Multi-Head Attention |
                <span class="badge badge-swa">SWA/Hybrid-SWA</span> Sliding Window
            </div>
        </div>
    </div>

    <script>
        const BUILTIN_MODELS = {
            "GPT-OSS-120B": {
                architectures: ["GptOssForCausalLM"],
                num_hidden_layers: 36,
                num_attention_heads: 64,
                num_key_value_heads: 8,
                head_dim: 64,
                hidden_size: 2880,
                max_position_embeddings: 131072,
                sliding_window: 128,
                layer_types: ["sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention"],
                total_params_b: 120,
                active_params_b: 20
            },
            "DeepSeek-V3": {
                architectures: ["DeepseekV3ForCausalLM"],
                num_hidden_layers: 61,
                kv_lora_rank: 512,
                qk_rope_head_dim: 64,
                num_attention_heads: 128,
                hidden_size: 7168,
                max_position_embeddings: 163840,
                total_params_b: 671,
                active_params_b: 37
            },
            "DeepSeek-R1": {
                architectures: ["DeepseekV3ForCausalLM"],
                num_hidden_layers: 61,
                kv_lora_rank: 512,
                qk_rope_head_dim: 64,
                num_attention_heads: 128,
                hidden_size: 7168,
                max_position_embeddings: 163840,
                total_params_b: 671,
                active_params_b: 37
            },
            "Kimi-K2": {
                architectures: ["DeepseekV3ForCausalLM"],
                model_type: "kimi_k2",
                num_hidden_layers: 61,
                kv_lora_rank: 512,
                qk_rope_head_dim: 64,
                num_attention_heads: 64,
                hidden_size: 7168,
                max_position_embeddings: 131072,
                total_params_b: 1029,
                active_params_b: 32
            },
            "GLM-4.5": {
                architectures: ["Glm4MoeForCausalLM"],
                num_hidden_layers: 92,
                num_attention_heads: 96,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 5120,
                max_position_embeddings: 131072,
                total_params_b: 358,
                active_params_b: 32
            },
            "MiniMax-M2.1": {
                architectures: ["MiniMaxM2ForCausalLM"],
                num_hidden_layers: 62,
                num_attention_heads: 48,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 3072,
                max_position_embeddings: 196608,
                total_params_b: 229,
                active_params_b: 10
            },
            "Qwen3-235B-A22B": {
                architectures: ["Qwen3MoeForCausalLM"],
                num_hidden_layers: 94,
                num_attention_heads: 64,
                num_key_value_heads: 4,
                head_dim: 128,
                hidden_size: 4096,
                max_position_embeddings: 40960,
                total_params_b: 235,
                active_params_b: 22
            },
            "Qwen2.5-72B": {
                architectures: ["Qwen2ForCausalLM"],
                num_hidden_layers: 80,
                num_attention_heads: 64,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 8192,
                max_position_embeddings: 32768,
                sliding_window: 131072,
                use_sliding_window: false,
                total_params_b: 72,
                active_params_b: 72
            },
            "Qwen2.5-7B": {
                architectures: ["Qwen2ForCausalLM"],
                num_hidden_layers: 28,
                num_attention_heads: 28,
                num_key_value_heads: 4,
                head_dim: 128,
                hidden_size: 3584,
                max_position_embeddings: 32768,
                total_params_b: 7,
                active_params_b: 7
            },
            "Llama-3.1-70B": {
                architectures: ["LlamaForCausalLM"],
                num_hidden_layers: 80,
                num_attention_heads: 64,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 8192,
                max_position_embeddings: 131072,
                total_params_b: 70,
                active_params_b: 70
            },
            "Llama-3.1-8B": {
                architectures: ["LlamaForCausalLM"],
                num_hidden_layers: 32,
                num_attention_heads: 32,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 4096,
                max_position_embeddings: 131072,
                total_params_b: 8,
                active_params_b: 8
            }
        };

        const MLA_ARCHITECTURES = [
            'DeepseekV2ForCausalLM', 'DeepseekV32ForCausalLM', 'DeepseekV3ForCausalLM',
            'DeepseekV3ForCausalLMNextN', 'DeepseekVL2ForCausalLM', 'LongcatFlashForCausalLM',
            'MistralLarge3ForCausalLM', 'PixtralForConditionalGeneration', 'MiniCPM3ForCausalLM',
            'KimiVLForConditionalGeneration', 'KimiLinearForCausalLM'
        ];

        const BYTES_PER_DTYPE = { bf16: 2, fp8: 1 };
        const WEIGHT_BYTES = { fp16: 2, fp8: 1, nvfp4: 0.56 };

        let models = {};
        let barChart, lineChart, scatterChartActive, scatterChartTotal, batchChart;

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function downloadChart(canvasId, filename, title) {
            const canvas = document.getElementById(canvasId);
            const titleHeight = 60;

            // Create a new canvas with space for title
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height + titleHeight;
            const ctx = exportCanvas.getContext('2d');

            // White background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

            // Draw title
            ctx.fillStyle = '#333333';
            ctx.font = 'bold 32px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(title, exportCanvas.width / 2, titleHeight - 16);

            // Draw chart
            ctx.drawImage(canvas, 0, titleHeight);

            // Draw attribution
            ctx.fillStyle = '#999999';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText('roofline.cc', exportCanvas.width - 10, exportCanvas.height - 10);

            const link = document.createElement('a');
            link.download = filename + '.png';
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        function isMLA(config) {
            if (config.kv_lora_rank) return true;
            return (config.architectures || []).some(a => MLA_ARCHITECTURES.includes(a));
        }

        function getSlidingWindow(config) {
            let sw = config.sliding_window;
            if (Array.isArray(sw)) sw = sw.find(v => v !== null);
            if (config.use_sliding_window === false) return null;
            return sw || null;
        }

        function calculateKVCache(config) {
            const numLayers = config.num_hidden_layers || 32;
            const useMLA = isMLA(config);
            const slidingWindow = getSlidingWindow(config);
            const layerTypes = config.layer_types || null;

            let bf16, fp8, kvHeads, headDim;
            let numFullLayers = numLayers;
            let numSlidingLayers = 0;

            if (layerTypes && Array.isArray(layerTypes)) {
                numFullLayers = layerTypes.filter(t => t === 'full_attention').length;
                numSlidingLayers = layerTypes.filter(t => t === 'sliding_attention').length;
            }

            if (useMLA) {
                const kvLoraRank = config.kv_lora_rank || 512;
                const qkRopeHeadDim = config.qk_rope_head_dim || 64;
                const latentDim = kvLoraRank + qkRopeHeadDim;
                bf16 = numLayers * latentDim * BYTES_PER_DTYPE.bf16;
                fp8 = numLayers * latentDim * BYTES_PER_DTYPE.fp8;
                kvHeads = 1;
                headDim = latentDim;
            } else {
                const numKVHeads = config.num_key_value_heads || config.num_attention_heads || 32;
                const defaultHeadDim = config.hidden_size ? Math.floor(config.hidden_size / (config.num_attention_heads || 32)) : 128;
                headDim = config.head_dim || defaultHeadDim;
                bf16 = 2 * numLayers * numKVHeads * headDim * BYTES_PER_DTYPE.bf16;
                fp8 = 2 * numLayers * numKVHeads * headDim * BYTES_PER_DTYPE.fp8;
                kvHeads = numKVHeads;
            }

            return {
                bf16, fp8, useMLA, slidingWindow,
                numLayers, kvHeads, headDim,
                numFullLayers, numSlidingLayers,
                hasHybrid: layerTypes !== null && numSlidingLayers > 0,
                maxCtx: config.max_position_embeddings || 32768
            };
        }

        function getKVCacheAtSeqLen(result, seqLen, dtype) {
            const bytesPerElement = BYTES_PER_DTYPE[dtype];
            
            if (result.hasHybrid && result.slidingWindow) {
                const bytesPerLayerPerToken = 2 * result.kvHeads * result.headDim * bytesPerElement;
                if (seqLen <= result.slidingWindow) {
                    return result.numLayers * bytesPerLayerPerToken * seqLen;
                } else {
                    const slidingContrib = result.numSlidingLayers * bytesPerLayerPerToken * result.slidingWindow;
                    const fullContrib = result.numFullLayers * bytesPerLayerPerToken * seqLen;
                    return slidingContrib + fullContrib;
                }
            }
            
            const bytesPerToken = dtype === 'fp8' ? result.fp8 : result.bf16;
            if (result.slidingWindow && seqLen > result.slidingWindow) {
                return bytesPerToken * result.slidingWindow;
            }
            return bytesPerToken * seqLen;
        }

        const COLORS = [
            '#6366f1', '#22c55e', '#f59e0b', '#ef4444', '#8b5cf6',
            '#06b6d4', '#ec4899', '#14b8a6', '#f97316', '#84cc16'
        ];

        function initModels() {
            models = { ...BUILTIN_MODELS };
        }

        function render() {
            const dtype = document.getElementById('dtype').value;

            const modelData = Object.entries(models).map(([name, config], index) => {
                const result = calculateKVCache(config);
                return { name, config, result, color: COLORS[index % COLORS.length] };
            });

            modelData.sort((a, b) => a.result.bf16 - b.result.bf16);

            renderBarChart(modelData, dtype);
            renderScatterChart(modelData, dtype, 'active', 'scatterChartActive');
            renderScatterChart(modelData, dtype, 'total', 'scatterChartTotal');
            renderLineChart(modelData, dtype);
            renderBatchChart(modelData, dtype);
            renderTable(modelData);
        }

        function renderBarChart(modelData, dtype) {
            const ctx = document.getElementById('barChart').getContext('2d');
            
            if (barChart) barChart.destroy();
            barChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: modelData.map(m => m.name),
                    datasets: [{
                        data: modelData.map(m => dtype === 'fp8' ? m.result.fp8 : m.result.bf16),
                        backgroundColor: modelData.map(m => {
                            if (m.result.useMLA) return '#c084fc';
                            if (m.result.slidingWindow) return '#fbbf24';
                            return '#4ade80';
                        })
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: function(items) {
                                    return items[0]?.label || '';
                                },
                                label: function(context) {
                                    const m = modelData[context.dataIndex];
                                    let label = context.raw.toLocaleString() + ' bytes/token';
                                    if (m.result.useMLA) label += ' (MLA)';
                                    else if (m.result.hasHybrid) label += ' (Hybrid-SWA)';
                                    else if (m.result.slidingWindow) label += ' (SWA)';
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Bytes/Token' } },
                        y: { ticks: { font: { size: 10 } } }
                    }
                }
            });
        }

        function renderScatterChart(modelData, dtype, paramType, canvasId) {
            const ctx = document.getElementById(canvasId).getContext('2d');

            // Filter to models that have size data
            const modelsWithSize = modelData.filter(m =>
                m.config.total_params_b !== undefined && m.config.active_params_b !== undefined
            );

            const data = modelsWithSize.map(m => {
                const params = paramType === 'total' ? m.config.total_params_b : m.config.active_params_b;
                const bytesPerToken = dtype === 'fp8' ? m.result.fp8 : m.result.bf16;
                return {
                    x: params,
                    y: bytesPerToken,
                    name: m.name,
                    model: m
                };
            });

            // Destroy existing chart
            if (paramType === 'active' && scatterChartActive) scatterChartActive.destroy();
            if (paramType === 'total' && scatterChartTotal) scatterChartTotal.destroy();

            const chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: modelsWithSize.map(m => {
                            if (m.result.useMLA) return '#c084fc';
                            if (m.result.slidingWindow) return '#fbbf24';
                            return '#4ade80';
                        }),
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: { top: 30 }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    const m = point.model;
                                    let label = `${point.name}: ${point.x}B params, ${point.y.toLocaleString()} bytes/token`;
                                    if (m.result.useMLA) label += ' (MLA)';
                                    else if (m.result.hasHybrid) label += ' (Hybrid-SWA)';
                                    else if (m.result.slidingWindow) label += ' (SWA)';
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'logarithmic',
                            title: { display: true, text: paramType === 'total' ? 'Total Parameters (B)' : 'Active Parameters (B)' },
                            ticks: {
                                callback: function(v) {
                                    if ([1, 2, 5, 10, 20, 50, 100, 200, 500, 1000].includes(v)) {
                                        return v + 'B';
                                    }
                                    return '';
                                }
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            title: { display: true, text: 'KV Cache Bytes per Token' },
                            ticks: { callback: v => v.toLocaleString() }
                        }
                    }
                },
                plugins: [{
                    id: 'labelPoints',
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        ctx.save();
                        ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#333';
                        
                        // Collect all label positions
                        const labels = [];
                        const meta = chart.getDatasetMeta(0);
                        
                        chart.data.datasets[0].data.forEach((point, i) => {
                            const element = meta.data[i];
                            if (element) {
                                const textWidth = ctx.measureText(point.name).width;
                                labels.push({
                                    name: point.name,
                                    x: element.x,
                                    y: element.y - 14,
                                    width: textWidth,
                                    height: 12,
                                    offsetY: -14
                                });
                            }
                        });
                        
                        // Simple collision resolution - iterate multiple times
                        for (let iteration = 0; iteration < 10; iteration++) {
                            for (let i = 0; i < labels.length; i++) {
                                for (let j = i + 1; j < labels.length; j++) {
                                    const a = labels[i];
                                    const b = labels[j];
                                    
                                    // Check for overlap
                                    const overlapX = Math.abs(a.x - b.x) < (a.width + b.width) / 2 + 4;
                                    const overlapY = Math.abs(a.y - b.y) < (a.height + b.height) / 2 + 2;
                                    
                                    if (overlapX && overlapY) {
                                        // Push labels apart vertically
                                        if (a.y < b.y) {
                                            a.y -= 6;
                                            b.y += 6;
                                        } else {
                                            a.y += 6;
                                            b.y -= 6;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Draw labels with leader lines if moved significantly
                        labels.forEach((label, i) => {
                            const element = meta.data[i];
                            const originalY = element.y - 14;
                            
                            // Draw leader line if label moved
                            if (Math.abs(label.y - originalY) > 10) {
                                ctx.beginPath();
                                ctx.strokeStyle = '#999';
                                ctx.lineWidth = 0.5;
                                ctx.moveTo(element.x, element.y - 8);
                                ctx.lineTo(label.x, label.y + 4);
                                ctx.stroke();
                            }
                            
                            ctx.textAlign = 'center';
                            ctx.fillText(label.name, label.x, label.y);
                        });

                        ctx.restore();
                    }
                }]
            });

            if (paramType === 'active') scatterChartActive = chart;
            else scatterChartTotal = chart;
        }

        function renderLineChart(modelData, dtype) {
            const ctx = document.getElementById('lineChart').getContext('2d');
            
            const seqLens = [];
            for (let i = 10; i <= 18; i += 0.25) seqLens.push(Math.round(Math.pow(2, i)));

            const datasets = modelData.map((m, idx) => ({
                label: m.name,
                data: seqLens.map(s => ({ x: s, y: getKVCacheAtSeqLen(m.result, s, dtype) })),
                borderColor: m.color,
                fill: false,
                pointRadius: 0,
                pointHoverRadius: 5,
                pointHoverBackgroundColor: m.color,
                borderWidth: 2,
                borderDash: m.result.slidingWindow ? [4, 4] : []
            }));

            if (lineChart) lineChart.destroy();
            lineChart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { position: 'right', labels: { boxWidth: 10, font: { size: 9 } } },
                        tooltip: {
                            callbacks: {
                                title: function(items) {
                                    if (items.length > 0) {
                                        const x = items[0].raw.x;
                                        return (x/1024) + 'K tokens';
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    return context.dataset.label + ': ' + formatBytes(context.raw.y);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'logarithmic',
                            title: { display: true, text: 'Sequence Length' },
                            min: 1024,
                            max: 262144,
                            ticks: { 
                                callback: function(v) {
                                    // 1K, 2K, 4K, 8K, 16K, 32K, 64K, 128K, 256K
                                    const validTicks = [1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144];
                                    if (validTicks.includes(v)) {
                                        return (v/1024) + 'K';
                                    }
                                    return '';
                                }
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            title: { display: true, text: 'KV Cache Size' },
                            ticks: { callback: v => formatBytes(v) }
                        }
                    }
                }
            });
        }

        function getBatchSliderValues() {
            const gpuMemoryGB = parseInt(document.getElementById('batch-gpu-memory').value);
            const numGpus = parseInt(document.getElementById('num-gpus').value);
            const weightDtype = document.getElementById('weight-dtype').value;
            return { gpuMemoryGB, numGpus, weightDtype };
        }

        function updateBatchSliderLabels() {
            const { gpuMemoryGB } = getBatchSliderValues();
            document.getElementById('batch-gpu-memory-value').textContent = gpuMemoryGB + ' GB';
        }

        function setGpuMemory(gb) {
            document.getElementById('batch-gpu-memory').value = gb;
            updateBatchSliderLabels();
            render();
        }

        function renderBatchChart(modelData, kvDtype) {
            const ctx = document.getElementById('batchChart').getContext('2d');
            const { gpuMemoryGB, numGpus, weightDtype } = getBatchSliderValues();
            const gpuMemoryBytes = gpuMemoryGB * 1024 * 1024 * 1024 * 0.9; // 90% usable
            const weightBytesPerParam = WEIGHT_BYTES[weightDtype];

            // Filter to models with parameter count
            const modelsWithParams = modelData.filter(m => m.config.total_params_b !== undefined);

            // Calculate max tokens in flight for each model
            const modelTokens = modelsWithParams.map(m => {
                const totalWeightBytes = m.config.total_params_b * 1e9 * weightBytesPerParam;
                const weightBytesPerGpu = totalWeightBytes / numGpus;
                const availableForKV = Math.max(0, gpuMemoryBytes - weightBytesPerGpu);
                const kvPerToken = kvDtype === 'fp8' ? m.result.fp8 : m.result.bf16;
                const maxTokens = availableForKV > 0 ? Math.floor(availableForKV / kvPerToken) : 0;
                return { ...m, maxTokens, weightBytesPerGpu, availableForKV };
            });

            // Sort by max tokens descending
            modelTokens.sort((a, b) => b.maxTokens - a.maxTokens);

            if (batchChart) batchChart.destroy();
            batchChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: modelTokens.map(m => m.name),
                    datasets: [{
                        data: modelTokens.map(m => m.maxTokens),
                        backgroundColor: modelTokens.map(m => {
                            if (m.maxTokens === 0) return '#dc2626';
                            if (m.result.useMLA) return '#c084fc';
                            if (m.result.slidingWindow) return '#fbbf24';
                            return '#4ade80';
                        })
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const m = modelTokens[context.dataIndex];
                                    const weightGB = (m.weightBytesPerGpu / (1024**3)).toFixed(1);
                                    const availGB = (m.availableForKV / (1024**3)).toFixed(1);
                                    if (m.maxTokens === 0) {
                                        return `Weights (${weightGB}GB) exceed GPU capacity`;
                                    }
                                    return [
                                        `${m.maxTokens.toLocaleString()} tokens (batch × seq_len)`,
                                        `Weights: ${weightGB}GB/GPU, KV headroom: ${availGB}GB`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'logarithmic',
                            title: { display: true, text: 'Max Tokens in Flight (batch × seq_len)' },
                            min: 500000,
                            ticks: {
                                callback: function(v) {
                                    if (v >= 1e6) return (v / 1e6).toFixed(0) + 'M';
                                    if (v >= 1e3) return (v / 1e3).toFixed(0) + 'K';
                                    return v;
                                }
                            }
                        },
                        y: { ticks: { font: { size: 10 } } }
                    }
                }
            });
        }

        function renderTable(modelData) {
            const tbody = document.getElementById('model-tbody');
            const ctx128k = 131072;

            tbody.innerHTML = modelData.map(m => {
                const r = m.result;

                let typeClass, typeText;
                if (r.useMLA) { typeClass = 'badge-mla'; typeText = 'MLA'; }
                else if (r.hasHybrid) { typeClass = 'badge-swa'; typeText = 'Hybrid-SWA'; }
                else if (r.slidingWindow) { typeClass = 'badge-swa'; typeText = 'SWA'; }
                else { typeClass = 'badge-mha'; typeText = 'MHA'; }

                const bf16At128k = getKVCacheAtSeqLen(r, ctx128k, 'bf16');
                const fp8At128k = getKVCacheAtSeqLen(r, ctx128k, 'fp8');

                let layersInfo = r.numLayers;
                if (r.hasHybrid) layersInfo = `${r.numFullLayers}F+${r.numSlidingLayers}S`;

                const bounded = r.slidingWindow && ctx128k > r.slidingWindow;

                return `<tr>
                    <td><strong>${m.name}</strong></td>
                    <td><span class="badge ${typeClass}">${typeText}</span></td>
                    <td>${layersInfo}</td>
                    <td>${r.useMLA ? '-' : r.kvHeads}</td>
                    <td>${r.headDim}</td>
                    <td>${r.bf16.toLocaleString()}</td>
                    <td>${r.fp8.toLocaleString()}</td>
                    <td>${formatBytes(bf16At128k)}${bounded ? '*' : ''}</td>
                    <td>${formatBytes(fp8At128k)}${bounded ? '*' : ''}</td>
                </tr>`;
            }).join('');
        }

        document.getElementById('dtype').addEventListener('change', render);
        document.getElementById('batch-gpu-memory').addEventListener('input', () => { updateBatchSliderLabels(); render(); });
        document.getElementById('num-gpus').addEventListener('change', render);
        document.getElementById('weight-dtype').addEventListener('change', render);

        initModels();
        updateBatchSliderLabels();
        render();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KV Cache Calculator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.5;
            padding: 1rem;
        }

        .container { max-width: 1200px; margin: 0 auto; }

        h1 { font-size: 1.5rem; margin-bottom: 1rem; }
        h2 { font-size: 1rem; margin-bottom: 0.5rem; font-weight: 600; }

        .card {
            background: white;
            border: 1px solid #ddd;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .chart-container { height: 400px; }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }

        th, td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th { font-weight: 600; background: #f9f9f9; }

        .badge {
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .badge-mla { background: #e9d5ff; color: #7c3aed; }
        .badge-mha { background: #d1fae5; color: #059669; }
        .badge-swa { background: #fef3c7; color: #d97706; }

        .add-section {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .input-group { flex: 1; min-width: 200px; }
        .input-group label { display: block; font-size: 0.8rem; margin-bottom: 0.25rem; }

        input, select {
            padding: 0.4rem;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.85rem;
            width: 100%;
        }

        button {
            padding: 0.4rem 0.8rem;
            background: #4f46e5;
            color: white;
            border: none;
            border-radius: 3px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        button:hover { background: #4338ca; }
        button:disabled { opacity: 0.6; cursor: not-allowed; }

        .remove-btn {
            background: transparent;
            color: #dc2626;
            padding: 0.2rem 0.4rem;
            font-size: 0.7rem;
        }

        .remove-btn:hover { background: #fee2e2; }

        .error {
            background: #fee2e2;
            border: 1px solid #dc2626;
            color: #dc2626;
            padding: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            display: none;
        }

        .error.visible { display: block; }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .controls select { width: auto; }

        .legend-note {
            font-size: 0.75rem;
            color: #666;
            margin-top: 0.5rem;
        }

        .table-wrap { max-height: 350px; overflow-y: auto; }

        .slider-controls {
            display: flex;
            gap: 2rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .slider-group {
            flex: 1;
            min-width: 200px;
        }

        .slider-group label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .slider-group label span {
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>KV Cache Calculator</h1>

        <div class="card">
            <h2>Add Custom Model</h2>
            <div class="add-section">
                <div class="input-group">
                    <label>HuggingFace Model Path</label>
                    <input type="text" id="model-path" placeholder="org/model-name">
                </div>
                <div class="input-group" style="max-width: 120px;">
                    <label>Display Name</label>
                    <input type="text" id="display-name" placeholder="Optional">
                </div>
                <button id="add-btn">Add</button>
            </div>
            <div class="error" id="error-message"></div>
        </div>

        <div class="card">
            <div class="controls">
                <label>Data Type:</label>
                <select id="dtype">
                    <option value="bf16">BF16</option>
                    <option value="fp8">FP8</option>
                </select>
            </div>
        </div>

        <div class="card">
            <h2>KV Cache Bytes per Token</h2>
            <div class="chart-container">
                <canvas id="barChart"></canvas>
            </div>
        </div>

        <div class="card">
            <h2>KV Cache Size vs Sequence Length</h2>
            <div class="chart-container">
                <canvas id="lineChart"></canvas>
            </div>
        </div>

        <div class="card">
            <h2>Max Requests per GPU</h2>
            <div class="slider-controls">
                <div class="slider-group">
                    <label>GPU Memory: <span id="gpu-memory-value">80 GB</span></label>
                    <input type="range" id="gpu-memory" min="8" max="256" value="80">
                </div>
                <div class="slider-group">
                    <label>Sequence Length: <span id="seq-length-value">32K</span></label>
                    <input type="range" id="seq-length" min="10" max="18" value="15" step="0.5">
                </div>
            </div>
            <div class="chart-container">
                <canvas id="requestsChart"></canvas>
            </div>
        </div>

        <div class="card">
            <h2>Model Details</h2>
            <div class="table-wrap">
                <table>
                    <thead>
                        <tr>
                            <th>Model</th>
                            <th>Type</th>
                            <th>Layers</th>
                            <th>KV Heads</th>
                            <th>Head Dim</th>
                            <th>BF16 B/tok</th>
                            <th>FP8 B/tok</th>
                            <th>128K BF16</th>
                            <th>128K FP8</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="model-tbody"></tbody>
                </table>
            </div>
            <div class="legend-note">
                <span class="badge badge-mla">MLA</span> Multi-head Latent Attention |
                <span class="badge badge-mha">MHA</span> Multi-Head Attention |
                <span class="badge badge-swa">SWA/Hybrid</span> Sliding Window
            </div>
        </div>
    </div>

    <script>
        const BUILTIN_MODELS = {
            "GPT-OSS-120B": {
                architectures: ["GptOssForCausalLM"],
                num_hidden_layers: 36,
                num_attention_heads: 64,
                num_key_value_heads: 8,
                head_dim: 64,
                hidden_size: 2880,
                max_position_embeddings: 131072,
                sliding_window: 128,
                layer_types: ["sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention","sliding_attention","full_attention"],
            },
            "DeepSeek-V3": {
                architectures: ["DeepseekV3ForCausalLM"],
                num_hidden_layers: 61,
                kv_lora_rank: 512,
                qk_rope_head_dim: 64,
                num_attention_heads: 128,
                hidden_size: 7168,
                max_position_embeddings: 163840
            },
            "DeepSeek-R1": {
                architectures: ["DeepseekV3ForCausalLM"],
                num_hidden_layers: 61,
                kv_lora_rank: 512,
                qk_rope_head_dim: 64,
                num_attention_heads: 128,
                hidden_size: 7168,
                max_position_embeddings: 163840
            },
            "Kimi-K2": {
                architectures: ["DeepseekV3ForCausalLM"],
                model_type: "kimi_k2",
                num_hidden_layers: 61,
                kv_lora_rank: 512,
                qk_rope_head_dim: 64,
                num_attention_heads: 64,
                hidden_size: 7168,
                max_position_embeddings: 131072
            },
            "GLM-4.5": {
                architectures: ["Glm4MoeForCausalLM"],
                num_hidden_layers: 92,
                num_attention_heads: 96,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 5120,
                max_position_embeddings: 131072
            },
            "MiniMax-M2.1": {
                architectures: ["MiniMaxM2ForCausalLM"],
                num_hidden_layers: 62,
                num_attention_heads: 48,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 3072,
                max_position_embeddings: 196608
            },
            "Qwen3-235B-A22B": {
                architectures: ["Qwen3MoeForCausalLM"],
                num_hidden_layers: 94,
                num_attention_heads: 64,
                num_key_value_heads: 4,
                head_dim: 128,
                hidden_size: 4096,
                max_position_embeddings: 40960
            },
            "Qwen2.5-72B": {
                architectures: ["Qwen2ForCausalLM"],
                num_hidden_layers: 80,
                num_attention_heads: 64,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 8192,
                max_position_embeddings: 32768,
                sliding_window: 131072,
                use_sliding_window: false
            },
            "Qwen2.5-7B": {
                architectures: ["Qwen2ForCausalLM"],
                num_hidden_layers: 28,
                num_attention_heads: 28,
                num_key_value_heads: 4,
                head_dim: 128,
                hidden_size: 3584,
                max_position_embeddings: 32768
            },
            "Mixtral-8x7B": {
                architectures: ["MixtralForCausalLM"],
                num_hidden_layers: 32,
                num_attention_heads: 32,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 4096,
                max_position_embeddings: 32768,
                sliding_window: null
            },
            "Mistral-7B": {
                architectures: ["MistralForCausalLM"],
                num_hidden_layers: 32,
                num_attention_heads: 32,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 4096,
                max_position_embeddings: 32768,
                sliding_window: 4096
            },
            "Llama-3.1-70B": {
                architectures: ["LlamaForCausalLM"],
                num_hidden_layers: 80,
                num_attention_heads: 64,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 8192,
                max_position_embeddings: 131072
            },
            "Llama-3.1-8B": {
                architectures: ["LlamaForCausalLM"],
                num_hidden_layers: 32,
                num_attention_heads: 32,
                num_key_value_heads: 8,
                head_dim: 128,
                hidden_size: 4096,
                max_position_embeddings: 131072
            }
        };

        const MLA_ARCHITECTURES = [
            'DeepseekV2ForCausalLM', 'DeepseekV32ForCausalLM', 'DeepseekV3ForCausalLM',
            'DeepseekV3ForCausalLMNextN', 'DeepseekVL2ForCausalLM', 'LongcatFlashForCausalLM',
            'MistralLarge3ForCausalLM', 'PixtralForConditionalGeneration', 'MiniCPM3ForCausalLM',
            'KimiVLForConditionalGeneration', 'KimiLinearForCausalLM'
        ];

        const BYTES_PER_DTYPE = { bf16: 2, fp8: 1 };

        let models = {};
        let customModels = {};
        let barChart, lineChart, requestsChart;

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function isMLA(config) {
            if (config.kv_lora_rank) return true;
            return (config.architectures || []).some(a => MLA_ARCHITECTURES.includes(a));
        }

        function getSlidingWindow(config) {
            let sw = config.sliding_window;
            if (Array.isArray(sw)) sw = sw.find(v => v !== null);
            if (config.use_sliding_window === false) return null;
            return sw || null;
        }

        function calculateKVCache(config) {
            const numLayers = config.num_hidden_layers || 32;
            const useMLA = isMLA(config);
            const slidingWindow = getSlidingWindow(config);
            const layerTypes = config.layer_types || null;

            let bf16, fp8, kvHeads, headDim;
            let numFullLayers = numLayers;
            let numSlidingLayers = 0;

            if (layerTypes && Array.isArray(layerTypes)) {
                numFullLayers = layerTypes.filter(t => t === 'full_attention').length;
                numSlidingLayers = layerTypes.filter(t => t === 'sliding_attention').length;
            }

            if (useMLA) {
                const kvLoraRank = config.kv_lora_rank || 512;
                const qkRopeHeadDim = config.qk_rope_head_dim || 64;
                const latentDim = kvLoraRank + qkRopeHeadDim;
                bf16 = numLayers * latentDim * BYTES_PER_DTYPE.bf16;
                fp8 = numLayers * latentDim * BYTES_PER_DTYPE.fp8;
                kvHeads = 1;
                headDim = latentDim;
            } else {
                const numKVHeads = config.num_key_value_heads || config.num_attention_heads || 32;
                const defaultHeadDim = config.hidden_size ? Math.floor(config.hidden_size / (config.num_attention_heads || 32)) : 128;
                headDim = config.head_dim || defaultHeadDim;
                bf16 = 2 * numLayers * numKVHeads * headDim * BYTES_PER_DTYPE.bf16;
                fp8 = 2 * numLayers * numKVHeads * headDim * BYTES_PER_DTYPE.fp8;
                kvHeads = numKVHeads;
            }

            return {
                bf16, fp8, useMLA, slidingWindow,
                numLayers, kvHeads, headDim,
                numFullLayers, numSlidingLayers,
                hasHybrid: layerTypes !== null && numSlidingLayers > 0,
                maxCtx: config.max_position_embeddings || 32768
            };
        }

        function getKVCacheAtSeqLen(result, seqLen, dtype) {
            const bytesPerElement = BYTES_PER_DTYPE[dtype];
            
            if (result.hasHybrid && result.slidingWindow) {
                const bytesPerLayerPerToken = 2 * result.kvHeads * result.headDim * bytesPerElement;
                if (seqLen <= result.slidingWindow) {
                    return result.numLayers * bytesPerLayerPerToken * seqLen;
                } else {
                    const slidingContrib = result.numSlidingLayers * bytesPerLayerPerToken * result.slidingWindow;
                    const fullContrib = result.numFullLayers * bytesPerLayerPerToken * seqLen;
                    return slidingContrib + fullContrib;
                }
            }
            
            const bytesPerToken = dtype === 'fp8' ? result.fp8 : result.bf16;
            if (result.slidingWindow && seqLen > result.slidingWindow) {
                return bytesPerToken * result.slidingWindow;
            }
            return bytesPerToken * seqLen;
        }

        const COLORS = [
            '#6366f1', '#22c55e', '#f59e0b', '#ef4444', '#8b5cf6',
            '#06b6d4', '#ec4899', '#14b8a6', '#f97316', '#84cc16'
        ];

        function initModels() {
            models = { ...BUILTIN_MODELS };
            try {
                const saved = localStorage.getItem('customModels');
                if (saved) customModels = JSON.parse(saved);
            } catch (e) {}
            Object.assign(models, customModels);
        }

        function render() {
            const dtype = document.getElementById('dtype').value;

            const modelData = Object.entries(models).map(([name, config], index) => {
                const result = calculateKVCache(config);
                return { name, config, result, color: COLORS[index % COLORS.length] };
            });

            modelData.sort((a, b) => a.result.bf16 - b.result.bf16);

            renderBarChart(modelData, dtype);
            renderLineChart(modelData, dtype);
            renderRequestsChart(modelData, dtype);
            renderTable(modelData);
        }

        function renderBarChart(modelData, dtype) {
            const ctx = document.getElementById('barChart').getContext('2d');
            
            if (barChart) barChart.destroy();
            barChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: modelData.map(m => m.name),
                    datasets: [{
                        data: modelData.map(m => dtype === 'fp8' ? m.result.fp8 : m.result.bf16),
                        backgroundColor: modelData.map(m => {
                            if (m.result.useMLA) return '#c084fc';
                            if (m.result.slidingWindow) return '#fbbf24';
                            return '#4ade80';
                        })
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: function(items) {
                                    return items[0]?.label || '';
                                },
                                label: function(context) {
                                    const m = modelData[context.dataIndex];
                                    let label = context.raw.toLocaleString() + ' bytes/token';
                                    if (m.result.useMLA) label += ' (MLA)';
                                    else if (m.result.hasHybrid) label += ' (Hybrid)';
                                    else if (m.result.slidingWindow) label += ' (SWA)';
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Bytes/Token' } },
                        y: { ticks: { font: { size: 10 } } }
                    }
                }
            });
        }

        function renderLineChart(modelData, dtype) {
            const ctx = document.getElementById('lineChart').getContext('2d');
            
            const seqLens = [];
            for (let i = 10; i <= 18; i += 0.25) seqLens.push(Math.round(Math.pow(2, i)));

            const datasets = modelData.map((m, idx) => ({
                label: m.name,
                data: seqLens.map(s => ({ x: s, y: getKVCacheAtSeqLen(m.result, s, dtype) })),
                borderColor: m.color,
                fill: false,
                pointRadius: 0,
                pointHoverRadius: 5,
                pointHoverBackgroundColor: m.color,
                borderWidth: 2,
                borderDash: m.result.slidingWindow ? [4, 4] : []
            }));

            if (lineChart) lineChart.destroy();
            lineChart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { position: 'right', labels: { boxWidth: 10, font: { size: 9 } } },
                        tooltip: {
                            callbacks: {
                                title: function(items) {
                                    if (items.length > 0) {
                                        const x = items[0].raw.x;
                                        return (x/1024) + 'K tokens';
                                    }
                                    return '';
                                },
                                label: function(context) {
                                    return context.dataset.label + ': ' + formatBytes(context.raw.y);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'logarithmic',
                            title: { display: true, text: 'Sequence Length' },
                            min: 1024,
                            max: 262144,
                            ticks: { 
                                callback: function(v) {
                                    // 1K, 2K, 4K, 8K, 16K, 32K, 64K, 128K, 256K
                                    const validTicks = [1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144];
                                    if (validTicks.includes(v)) {
                                        return (v/1024) + 'K';
                                    }
                                    return '';
                                }
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            title: { display: true, text: 'KV Cache Size' },
                            ticks: { callback: v => formatBytes(v) }
                        }
                    }
                }
            });
        }

        function getSliderValues() {
            const gpuMemoryGB = parseInt(document.getElementById('gpu-memory').value);
            const seqLengthExp = parseFloat(document.getElementById('seq-length').value);
            const seqLength = Math.round(Math.pow(2, seqLengthExp));
            return { gpuMemoryGB, seqLength };
        }

        function updateSliderLabels() {
            const { gpuMemoryGB, seqLength } = getSliderValues();
            document.getElementById('gpu-memory-value').textContent = gpuMemoryGB + ' GB';
            document.getElementById('seq-length-value').textContent = (seqLength / 1024) + 'K';
        }

        function renderRequestsChart(modelData, dtype) {
            const ctx = document.getElementById('requestsChart').getContext('2d');
            const { gpuMemoryGB, seqLength } = getSliderValues();
            const gpuMemoryBytes = gpuMemoryGB * 1024 * 1024 * 1024;

            const requestCounts = modelData.map(m => {
                const kvPerRequest = getKVCacheAtSeqLen(m.result, seqLength, dtype);
                return Math.floor(gpuMemoryBytes / kvPerRequest);
            });

            // Sort by request count descending for this chart
            const sorted = modelData.map((m, i) => ({ ...m, requests: requestCounts[i] }))
                .sort((a, b) => b.requests - a.requests);

            if (requestsChart) requestsChart.destroy();
            requestsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sorted.map(m => m.name),
                    datasets: [{
                        data: sorted.map(m => m.requests),
                        backgroundColor: sorted.map(m => {
                            if (m.result.useMLA) return '#c084fc';
                            if (m.result.slidingWindow) return '#fbbf24';
                            return '#4ade80';
                        })
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: function(items) {
                                    return items[0]?.label || '';
                                },
                                label: function(context) {
                                    const m = sorted[context.dataIndex];
                                    const kvSize = getKVCacheAtSeqLen(m.result, seqLength, dtype);
                                    return `${context.raw.toLocaleString()} requests (${formatBytes(kvSize)}/req)`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { title: { display: true, text: 'Max Concurrent Requests' } },
                        y: { ticks: { font: { size: 10 } } }
                    }
                }
            });
        }

        function renderTable(modelData) {
            const tbody = document.getElementById('model-tbody');
            const ctx128k = 131072;

            tbody.innerHTML = modelData.map(m => {
                const r = m.result;
                const isCustom = m.name in customModels;
                
                let typeClass, typeText;
                if (r.useMLA) { typeClass = 'badge-mla'; typeText = 'MLA'; }
                else if (r.hasHybrid) { typeClass = 'badge-swa'; typeText = 'Hybrid'; }
                else if (r.slidingWindow) { typeClass = 'badge-swa'; typeText = 'SWA'; }
                else { typeClass = 'badge-mha'; typeText = 'MHA'; }
                
                const bf16At128k = getKVCacheAtSeqLen(r, ctx128k, 'bf16');
                const fp8At128k = getKVCacheAtSeqLen(r, ctx128k, 'fp8');
                
                let layersInfo = r.numLayers;
                if (r.hasHybrid) layersInfo = `${r.numFullLayers}F+${r.numSlidingLayers}S`;
                
                const bounded = r.slidingWindow && ctx128k > r.slidingWindow;

                return `<tr>
                    <td><strong>${m.name}</strong></td>
                    <td><span class="badge ${typeClass}">${typeText}</span></td>
                    <td>${layersInfo}</td>
                    <td>${r.useMLA ? '-' : r.kvHeads}</td>
                    <td>${r.headDim}</td>
                    <td>${r.bf16.toLocaleString()}</td>
                    <td>${r.fp8.toLocaleString()}</td>
                    <td>${formatBytes(bf16At128k)}${bounded ? '*' : ''}</td>
                    <td>${formatBytes(fp8At128k)}${bounded ? '*' : ''}</td>
                    <td>${isCustom ? `<button class="remove-btn" onclick="removeModel('${m.name}')">Ã—</button>` : ''}</td>
                </tr>`;
            }).join('');
        }

        async function addModel() {
            const modelPath = document.getElementById('model-path').value.trim();
            const displayName = document.getElementById('display-name').value.trim() || modelPath.split('/').pop();
            const errorDiv = document.getElementById('error-message');

            if (!modelPath) {
                errorDiv.textContent = 'Please enter a model path';
                errorDiv.classList.add('visible');
                return;
            }

            errorDiv.classList.remove('visible');
            document.getElementById('add-btn').disabled = true;

            try {
                const url = `https://huggingface.co/${modelPath}/raw/main/config.json`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const config = await response.json();
                
                models[displayName] = config;
                customModels[displayName] = config;
                localStorage.setItem('customModels', JSON.stringify(customModels));
                
                document.getElementById('model-path').value = '';
                document.getElementById('display-name').value = '';
                render();
            } catch (error) {
                errorDiv.textContent = `Error: ${error.message}`;
                errorDiv.classList.add('visible');
            } finally {
                document.getElementById('add-btn').disabled = false;
            }
        }

        function removeModel(name) {
            delete models[name];
            delete customModels[name];
            localStorage.setItem('customModels', JSON.stringify(customModels));
            render();
        }

        document.getElementById('add-btn').addEventListener('click', addModel);
        document.getElementById('model-path').addEventListener('keypress', e => { if (e.key === 'Enter') addModel(); });
        document.getElementById('dtype').addEventListener('change', render);
        document.getElementById('gpu-memory').addEventListener('input', () => { updateSliderLabels(); render(); });
        document.getElementById('seq-length').addEventListener('input', () => { updateSliderLabels(); render(); });

        initModels();
        updateSliderLabels();
        render();
    </script>
</body>
</html>
